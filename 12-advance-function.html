<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Advance Function</title>
</head>

<body>
	<button onclick="" class="js-button">Click</button>

	<script>
		const buttonElement = document.querySelector('.js-button');

		const eventListener = () => {
			console.log('click');
		};

		buttonElement.addEventListener('click', eventListener);

		// removeEventListener('event', function name)
		buttonElement.removeEventListener('click', eventListener);

		buttonElement.addEventListener('click', () => {
			console.log('click2');
		});

		/*
		greeting(); // ==> HOISTING
		function greeting() {
			console.log('hello 1');
		}

		greeting();

		const num = 2;
		// SAVE FUNCTION INSIDE VARIABLE
		// Anonymous function = a function without a name
		const function1 = function () {
			console.log('hello 2');
		};

		console.log(function1);
		console.log(typeof function1);
		function1();

		// SAVE A VALUE IN AN OBJECT
		const object1 = {
			num: 2,
			fun: function () {
				// this is method (function saved inside an object)
				console.log('hello 3');
			}
		};
		object1.fun();

		// PASSING A VALUE INTO A FUNCTION
		function display(param) {
			console.log(param);
		}
		display(2);

		// PASS A FUNCTION INTO ANOTHER FUNCTION
		function run(param) {
			param();
		}
		// Function bellow called as CALLBACK
		run(function () {
			console.log('hello 4');
		});
		*/

		/*
		// setTimeout()
		// - Allow us to run a function in the future.
		// - SetTimeout takes two parameter
		// The advantage:
		// - it doesn't block our code for certain time
		setTimeout(function () {
			console.log('timeout');
			console.log('timeout2');
		}, 2500);

		// ASYNCHRONOUS CODE
		// - Asynchronous code won't wait for a line to finish before going to the next line.
		console.log('next line');

		// SYNCHRONOUS CODE
		// - will wait for one line to finish before going to the next line


		// setInterval()
		// - setInterval is also Asynchronous
		// - it will keep running a function in the future
		setInterval(function () {
			console.log('interval');
		}, 3000);

		console.log('next line 2');
		*/

		/*
		// FOR EACH (.forEach)`

		[
			'make dinner',
			'build keyboard',
			'learning code'
		].forEach((value, index) => { // TURN INTO ARROW FUNCTION
			if (value === 'build keyboard') { // continue: skip to the next iteration
				return; // return does the same thing as continue
			}
			console.log(index);
			console.log(value);
		});

		// ARROW FUNCTION
		const regularFunction = function (param, param2) {
			console.log('hello regular');
			return 5;
		};
		regularFunction();
		const arrowFunction = (param, param2) => {
			console.log('hello arrow');
			return 5;
		};
		arrowFunction();

		// ARROW FUNCTION SHORTCUT
		const oneParam = param => {
			console.log(param + 1);
		};
		oneParam(2);

		// - when arrow function has only one line. we can put it on the same line
		// - curly braces are optional
		// - we can remove the return statement
		const oneLine = () => 2 + 3;
		console.log(oneLine());

		// we could use arrow function inside an object
		const object2 = {
			method: () => {
				
			},
			method() {
				
			}
		};
		*/

	</script>
</body>

</html>